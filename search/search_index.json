{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SPARQL2GrahpQL Many government and non-government organizations today publish various datasets using Linked Data through SPARQL endpoints. These datasets are often also available as JSON or RDF dumps, but having to write code to explore them can be cumbersome. SPARQL2GraphQL aims to make it easier to use these datasets by providing a tool which will give developers a more friendly interface which they likely already know how to use - GraphQL. Simply configure SPARQL2GraphQL with the URL of a SPARQL endpoint which has some data which interests you, and let it do its magic. Soon, you will have a GraphQL instance which you can use to painlessly explore and query the data. If you want to get started right away, check out the usage guide . If you want to find out how it works, find that out here . If you wish to tinker with the project's code, or even contribute to it, here is a development handbook.","title":"Home"},{"location":"#sparql2grahpql","text":"Many government and non-government organizations today publish various datasets using Linked Data through SPARQL endpoints. These datasets are often also available as JSON or RDF dumps, but having to write code to explore them can be cumbersome. SPARQL2GraphQL aims to make it easier to use these datasets by providing a tool which will give developers a more friendly interface which they likely already know how to use - GraphQL. Simply configure SPARQL2GraphQL with the URL of a SPARQL endpoint which has some data which interests you, and let it do its magic. Soon, you will have a GraphQL instance which you can use to painlessly explore and query the data. If you want to get started right away, check out the usage guide . If you want to find out how it works, find that out here . If you wish to tinker with the project's code, or even contribute to it, here is a development handbook.","title":"SPARQL2GrahpQL"},{"location":"development/","text":"Development Build, lint and test are automatically run in GitHub Actions. They are required to pass for every PR and commit to master . Contributions should be in the form of PRs opened against master , containing a comprehensive description of what was changed and why. Bonus points if you include a video or screenshot showcasing the functionality. Tests should also be included with contributions. Development should follow GitHub Flow and commit messages should follow the Conventional Commits spec. Useful commands The following commands will likely be useful to you during development. Install dependencies npm ci or npm install - both will install the dependencies, but npm ci will make sure that they match package-lock.json exactly, and may take longer to run. Compile everything npm run build will compile the TypeScript files. Linting npm run lint will list all linting issues without fixing them automatically. Formatting (lint w/ autofix) npm run format will run linting and auto-fix all possible issues. Running npm start will start the app. Alternatively, if you use VSCode for development, a Debug API debug config is included in the repository. Running this debugging config will automatically compile the required files and run the app in debug mode. Testing npm test will run tests with Jest and generate a testing + coverage report. Editing documentation The documentation is generated using mkdocs from the Markdown files in the docs directory, and manually deployed to GitHub Pages with mkdocs gh-deploy .","title":"Development"},{"location":"development/#development","text":"Build, lint and test are automatically run in GitHub Actions. They are required to pass for every PR and commit to master . Contributions should be in the form of PRs opened against master , containing a comprehensive description of what was changed and why. Bonus points if you include a video or screenshot showcasing the functionality. Tests should also be included with contributions. Development should follow GitHub Flow and commit messages should follow the Conventional Commits spec.","title":"Development"},{"location":"development/#useful-commands","text":"The following commands will likely be useful to you during development.","title":"Useful commands"},{"location":"development/#install-dependencies","text":"npm ci or npm install - both will install the dependencies, but npm ci will make sure that they match package-lock.json exactly, and may take longer to run.","title":"Install dependencies"},{"location":"development/#compile-everything","text":"npm run build will compile the TypeScript files.","title":"Compile everything"},{"location":"development/#linting","text":"npm run lint will list all linting issues without fixing them automatically.","title":"Linting"},{"location":"development/#formatting-lint-w-autofix","text":"npm run format will run linting and auto-fix all possible issues.","title":"Formatting (lint w/ autofix)"},{"location":"development/#running","text":"npm start will start the app. Alternatively, if you use VSCode for development, a Debug API debug config is included in the repository. Running this debugging config will automatically compile the required files and run the app in debug mode.","title":"Running"},{"location":"development/#testing","text":"npm test will run tests with Jest and generate a testing + coverage report.","title":"Testing"},{"location":"development/#editing-documentation","text":"The documentation is generated using mkdocs from the Markdown files in the docs directory, and manually deployed to GitHub Pages with mkdocs gh-deploy .","title":"Editing documentation"},{"location":"how-it-works/","text":"How it works title how it works content","title":"How it works"},{"location":"how-it-works/#how-it-works-title","text":"how it works content","title":"How it works title"},{"location":"postprocessing/","text":"","title":"Postprocessing"},{"location":"usage/","text":"Usage guide This page will explain how to set up SPARQL2GraphQL for a given SPARQL endpoint, step-by-step. Installing dependencies The project is written in TypeScript and uses Node.js as its runtime. You will need to have the following installed before you proceed with usage: Node 16.13.0 (Gallium LTS) - easily managed with nvm npm Once you have installed them, run npm install in the project root directory to install all required dependencies with npm. Edit configuration TODO: fix code file links There is one required configuration step before you run the project - configuring the SPARQL endpoint you want to run. In config.ts , set the value ENDPOINT_TO_RUN to refer to your endpoint. There is a pre-defined list of endpoints in endpoints.ts in case you just want to try the project without having a specific SPARQL endpoint in mind, but you can easily define your own like so: export const ENDPOINT_TO_RUN = { url: 'https://data.europa.eu/sparql', name: 'European Data', }; The name can be whatever you want, it's just an easily readable identifier used in logs. There are other configuration values which you are free to modify, but they have sensible defaults in case you just want to get started. Run it After everything is configured, run npm start to start SPARQL2GraphQL. In the logs, you will see that it will first run some observations on the target endpoint to collect information about its schema and the data contained within. This may take a while, especially for large datasets, depending on the configuration parameters used. After observation is finished, you will see that a fully functional GraphQL interface is available for you to explore at the configured port (http://localhost:4000 by default).","title":"Usage"},{"location":"usage/#usage-guide","text":"This page will explain how to set up SPARQL2GraphQL for a given SPARQL endpoint, step-by-step.","title":"Usage guide"},{"location":"usage/#installing-dependencies","text":"The project is written in TypeScript and uses Node.js as its runtime. You will need to have the following installed before you proceed with usage: Node 16.13.0 (Gallium LTS) - easily managed with nvm npm Once you have installed them, run npm install in the project root directory to install all required dependencies with npm.","title":"Installing dependencies"},{"location":"usage/#edit-configuration","text":"TODO: fix code file links There is one required configuration step before you run the project - configuring the SPARQL endpoint you want to run. In config.ts , set the value ENDPOINT_TO_RUN to refer to your endpoint. There is a pre-defined list of endpoints in endpoints.ts in case you just want to try the project without having a specific SPARQL endpoint in mind, but you can easily define your own like so: export const ENDPOINT_TO_RUN = { url: 'https://data.europa.eu/sparql', name: 'European Data', }; The name can be whatever you want, it's just an easily readable identifier used in logs. There are other configuration values which you are free to modify, but they have sensible defaults in case you just want to get started.","title":"Edit configuration"},{"location":"usage/#run-it","text":"After everything is configured, run npm start to start SPARQL2GraphQL. In the logs, you will see that it will first run some observations on the target endpoint to collect information about its schema and the data contained within. This may take a while, especially for large datasets, depending on the configuration parameters used. After observation is finished, you will see that a fully functional GraphQL interface is available for you to explore at the configured port (http://localhost:4000 by default).","title":"Run it"}]}